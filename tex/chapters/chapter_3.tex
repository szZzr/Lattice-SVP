\section{Πρόβλημα Εύρεσης Μικρότερου Διανύσματος}
\label{chapSVP}

Στην παρούσα πτυχιακή εργασία όπως έχουμε ήδη αναφέρει, ασχολούμαστε με την επίλυση του προβλήματος μικρότερου διανύσματος SVP. Προηγουμένως, αναφερθήκαμε σε αλγορίθμους που προσεγγίζουν το πρόβλημα ως αναγωγή της δοθείσας βάσης (lattice reduction). 

Συγκεκριμένα αυτοί οι αλγόριθμοι, επιχειρούν διαδοχικούς μετασχηματισμούς στη βάση του πλέγματος, προκειμένου να καταλήξουν με μικρότερα και όσο το δυνατόν ορθογώνια διανύσματα, δίνοντας έτσι απάντηση και στο $SVP_\gamma $. Μολονότι για συνήθεις παραμέτρους απαιτούν πολυωνυμικό χρόνο, ο παράγοντας προσέγγισης $ \gamma $ που πετυχαίνουν είναι ασυμπτωτικά εκθετικός. Στην υλοποίησή μας, επιλέξαμε να χρησιμοποιήσουμε μία διαφορετική αλγοριθμική τεχνική, αυτή της απαρίθμησης. Στη συνέχεια παρουσιάζουμε τη συγκεκριμένη οικογένεια αλγορίθμων. 

\subsection{Αλγόριθμος απαρίθμησης \lt KFP}

Δοθείσας μίας βάσης $ B = \{\bm b_1, ..., \bm b_n \} $ και ενός άνω ορίου $ R $ για το ελάχιστο μήκος διανύσματος $ λ_1(L) $, αναζητούμε όλα τα διανύσματα $\bm v \in L - \{{\bf 0}\} $ που ικανοποιούν τη συνθήκη $ \| \bm v \| \leq R $.

Για το σκοπό αυτό, ο αλγόριθμος δημιουργεί ένα δέντρο απαρίθμησης (enumeration tree) που αποτελείται από όλα τα διανύσματα των πλεγμάτων προβολής $ \pi_n(L), \pi_{n-1}(L), ..., \pi_1(L) $, μέτρου το πολύ $ R $. Πιο συγκεκριμένα, το δέντρο απαρίθμησης έχει βάθος $ n $ και σε κάθε επίπεδο $ k $ βρίσκονται όλα τα διανύσματα του πλέγματος $ \pi_{n+1-k}(L) $, υπό τον περιορισμό πάντοτε ότι η νόρμα τους δεν ξεπερνά το όριο $ R $. Στη ρίζα του δέντρου βρίσκεται το μηδενικό διάνυσμα $ \bm 0 = \pi_{n+1}(L) $. Η διάταξη αυτή των διαδοχικών προβολών, μας εξασφαλίζει ότι όλοι οι πρόγονοι ενός κόμβου, έχουν το πολύ το ίδιο μήκος με τον κόμβο που έπεται. Δηλαδή:

$$ \| \pi_n( \bm v) \|^2 \leq \| \pi_{n-1}( \bm v) \|^2 \leq ... \leq \| \pi_1(\bm v) \|^2 = \| \bm v \|^2 \leq R^2 $$

Επίσης ένα διάνυσμα $ \bm v $ μπορεί να γραφτεί ως $ \bm v = u_1 \bm b_1 + \cdots + u_n \bm b_n $, όπου 

$$ \bm b_i = \bm b_i^* + \sum_{j=1}^{i-1} μ_{i,j} \bm b_j^* $$

Δηλαδή:

$$ \bm v = \sum_{j=1}^n(u_j + \sum_{i=j+1}^n μ_{i,j} u_i) \bm b_j^*, $$

οπότε και για τις νόρμες των προβολών έχουμε:

\begin{equation}
    \| \pi_{n+1-k}(\bm v) \|^2 = \sum_{j=n+1-k}^n  \bigg( u_j + \sum_{i=j+1}^n μ_{i,j} u_i  \bigg) ^2 \| \bm b_j^* \|^2, 1 \leq k \leq n. 
\end{equation}

Προκύπτει λοιπόν ένα σύνολο $ n $ ανισοτήτων. Αν ξεκινήσουμε από το $ \pi_n( \bm v)$, το οποίο ορίζεται μόνο από το διάνυσμα βάσης $\bm b_n $, μπορούμε να αποφανθούμε για το διάστημα στο οποίο επιτρέπεται να λάβει τιμές, ο αντίστοιχος συντελεστής του διανύσματος αυτού. Έχοντας βρει (απαριθμήσει) τις ακέραιες πιθανές τιμές για τον πρώτο συντελεστή, μπορούμε να προχωρήσουμε στη δεύτερη ανισότητα και να εξασφαλίσουμε τις τιμές και για τον δεύτερο.

Η διαδικασία επαναλαμβάνεται διαδοχικά για όλες τις ανισότητες, οπότε και προκύπτει το δέντρο απαρίθμησης με όλους τους πιθανούς συντελεστές για κάθε $\bm b_i $, ανά επίπεδο. Ειδικά για τον πρώτο συντελεστή περιορίζουμε την αναζήτηση μόνο σε θετικές τιμές, καθώς διαφορετικά θα οδηγούμασταν σε ένα συμμετρικό δέντρο, λόγο του ότι, αν $ \bm x \in L $ και $ - \bm x \in L $ .

Σημειώνουμε, ότι το πλήθος των κόμβων του δέντρου, εξαρτάται και από την ποιότητα της βάσης, για αυτό συνηθέστερα πριν την εφαρμογή του αλγορίθμου απαρίθμησης προηγείται κάποια αναγωγή βάσης, όπως η LLL.  

Η διάσχιση τώρα του δέντρου απαρίθμησης γίνεται κατά βάθος, με χρήση του αλγορίθμου DFS, ώστε να έχουμε μειωμένες απαιτήσεις μνήμης. Αν ο αλγόριθμος καταλήξει σε κάποιο φύλλο του δέντρου, επιστρέφει το σχηματιζόμενο διάνυσμα, υπό την προϋπόθεσή ότι το μήκος του δεν ξεπερνά το όριο $R$. Η εκτέλεση του αλγορίθμου μπορεί να είναι αποτυχημένη, αν δεν βρεθεί κάποιο άλλο διάνυσμα πέρα από το μηδενικό. Στη συνέχεια παραθέτουμε σε μορφή ψευτοκώδικα τον αλγόριθμο που μόλις περιγράψαμε.   


\begin{algorithm}[h] \label{KFP}
\SetAlgoLined

{\bf Είσοδος:} Μία βάση $ B = \{\bm b_1, ..., \bm b_n \} $ του $ \mathbb{R}^n $, η οποία ορίζει το πλέγμα $ L(B) $ και ένα θετικό αριθμό R.  \\
{\bf Έξοδος:} Τα διανύσματα $ \bm x \in L $ με $ \| \bm x \| \leq R $.

\hfill

$ B^*, μ = LLL(B) $ \# Calculate a reduced base with an algorithm such as LLL \\
$ \bm x = (x_i) \gets \bm 0_n, c = (c_i) \gets \bm 0_n, l = (l_i) \gets \bm 0_n $ \\
$ sumli \gets 0, S = \emptyset, i \gets 1 $

\While{$ i \leq n $} {
    $ c_i \gets - \sum_{j=i+1}^n x_j μ_{ji}$  \\
    $ l_i \gets B_i(x_i - c_i)^2 $ \\
    $ sumli \gets \sum_{j=1}^n l_j $ \\
    \eIf{$ sumli \leq R^2 $}{
         \eIf{$ i = 1 $}{
            $ S \gets S \cup \{ \sum_{j=1}^n x_j b_j \} $ \\
            $ x_1 \gets x_1 + 1 $ \\
        }
        {
            $ i = i - 1 $ \\
            $ x_i \gets - \sum_{j=i+1}^n μ_{j,i} x_j - \sqrt{\frac{R^2 - \sum_{j=i+1}^n I_j}{B_i}} $ \\ \# left end of interval $ I_i$
        }
    }
    {
        $ i = i + 1 $ \\
        $ x_i \gets x_i + 1 $ \\
    }
    
} % end of while
return $ S $

\caption{KFP Algorithm}
\end{algorithm}

Όσο αφορά την πολυπλοκότητα του αλγορίθμου KFP, αυτή είναι πολυωνυμική ως προς το πλήθος $ Ν $ των κόμβων του δέντρου απαρίθμησης. Αποδεικνύεται \cite{journals/corr/abs-0705-0965} ότι ένα άνω όριο για το πλήθος είναι αυτό $ Ν \leq n^{n/(2e)+o(n)}$ και ακόμα ότι υπάρχει πολυώνυμο $ p(x,y) \in \mathbb{R}[x,y] $, ώστε για κάθε πλέγμα τάξης $n$, διάστασης $m$ και με συντελεστές βάσης που φράσονται από το $ B $, η πολυπλοκότητα του αλγορίθμου να είναι: 

$$ p(log_2(B), m) n^{n/(2e)+o(n)} $$  

\subsection{Βελτιστοποιήσεις του αλγορίθμου απαρίθμησης }

Σε αυτήν παράγραφο αναφέρουμε κάποιες σημαντικές βελτιστοποιήσεις που έχουν προταθεί για τον αλγόριθμο KFP. Αρχικά οι \lt Schnorr-Euchner πρότειναν ο συντελεστής $ x_i $ αντί να λαμβάνει διαδοχικά τιμές από την αρχή του διαστήματος $ I_i $ , να εκκινεί από την ποσότητα: $ \lceil \sum_{j=i+1}^n μ_{j,i} x_j \rfloor $, που βρίσκεται περίπου στη μέση του διαστήματος $ I_i $ και κατόπιν να αυξάνεται είτε να μειώνεται κατά 1. Η συγκεκριμένη παραλλαγή ονομάζεται και αλγόριθμος απαρίθμησης των Schnorr-Euchner.

Μία άλλη παραλλαγή του βασικού αλγορίθμου, εισάγει κάποιους όρους φθοράς $ a_i \in (0,1) $ με τους οποίους αναπροσαρμόζουμε το όριο αποδοχής ως $ R_i = a_iR $ για κάθε βάθος $ i $. Η παραλλαγή αυτή ονομάζεται και απαρίθμηση με κλάδεμα. Στόχος είναι να περιορίσουμε το υπολογιστικό κόστος, μειώνοντας το χώρο αναζήτησης διανυσμάτων. Ωστόσο, είναι πιθανό ο αλγόριθμός μας να μην επιστρέψει κάποια λύση, παρόλο που μπορεί να υπάρχει διάνυσμα με μήκος μικρότερου του $ R $.  

%\subsection{\lt Pruning}

% \newpage

